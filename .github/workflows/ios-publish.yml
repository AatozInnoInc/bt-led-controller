name: iOS Publish to TestFlight

on:
  # Only allow manual triggering - you want explicit control over what gets published
  # This workflow builds a fresh App Store IPA and uploads it to TestFlight
  workflow_dispatch:

jobs:
  publish-testflight:
    runs-on: macos-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
      
      - name: Install Pods
        working-directory: ios
        run: pod install
      
      # For TestFlight publishing, we MUST use the App Store provisioning profile
      # TestFlight will reject any build that isn't signed with an App Store profile
      # Ad Hoc profiles cannot be used for TestFlight distribution
      - name: Setup code signing for App Store
        id: setup-code-signing
        env:
          CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          PROVISIONING_PROFILE_APPSTORE_BASE64: ${{ secrets.PROVISIONING_PROFILE_APPSTORE_BASE64 }}
        run: |
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERT_BASE64_FILE=$RUNNER_TEMP/cert.b64
          PP_BASE64_FILE=$RUNNER_TEMP/pp.b64

          # Validate secrets
          if [ -z "$CERTIFICATE_BASE64" ]; then
            echo "ERROR: BUILD_CERTIFICATE_BASE64 secret is not set"
            exit 1
          fi
          
          if [ -z "$PROVISIONING_PROFILE_APPSTORE_BASE64" ]; then
            echo "ERROR: PROVISIONING_PROFILE_APPSTORE_BASE64 secret is not set"
            exit 1
          fi

          echo "Certificate base64 length: ${#CERTIFICATE_BASE64}"
          echo "Provisioning profile base64 length: ${#PROVISIONING_PROFILE_APPSTORE_BASE64}"

          # Write and decode certificate
          echo "$CERTIFICATE_BASE64" > $CERT_BASE64_FILE
          echo "$PROVISIONING_PROFILE_APPSTORE_BASE64" > $PP_BASE64_FILE

          base64 --decode -i $CERT_BASE64_FILE -o $CERTIFICATE_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode certificate"
            exit 1
          fi
          
          base64 --decode -i $PP_BASE64_FILE -o $PP_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode provisioning profile"
            exit 1
          fi

          if [ ! -s "$CERTIFICATE_PATH" ] || [ ! -s "$PP_PATH" ]; then
            echo "ERROR: Decoded files are empty"
            exit 1
          fi

          echo "Successfully decoded certificate ($(wc -c < $CERTIFICATE_PATH) bytes)"
          echo "Successfully decoded provisioning profile ($(wc -c < $PP_PATH) bytes)"

          # Setup keychain and import certificate
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          security import $CERTIFICATE_PATH \
            -P "$CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k $KEYCHAIN_PATH
          
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" \
            $KEYCHAIN_PATH
          
          echo "Available code signing identities:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

          # Install provisioning profile with proper UUID-based naming
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles
          
          PP_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(security cms -D -i $PP_PATH))
          PP_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin <<< $(security cms -D -i $PP_PATH))
          echo "Provisioning profile UUID: $PP_UUID"
          echo "Provisioning profile Name: $PP_NAME"
          echo "PP_NAME=$PP_NAME" >> $GITHUB_OUTPUT
          
          mv ~/Library/MobileDevice/Provisioning\ Profiles/build_pp.mobileprovision \
             ~/Library/MobileDevice/Provisioning\ Profiles/$PP_UUID.mobileprovision

          rm -f $CERT_BASE64_FILE $PP_BASE64_FILE
          echo "Code signing configured for App Store distribution"
      
      # Build for TestFlight submission
      # This MUST be a Release build with the App Store provisioning profile
      # TestFlight will reject builds signed with any other profile type
      - name: Build for TestFlight
        env:
          PP_NAME: ${{ steps.setup-code-signing.outputs.PP_NAME }}
        working-directory: ios
        run: |
          WORKSPACE="MyLedGuitarApp.xcworkspace"
          SCHEME="MyLedGuitarApp"
          
          echo "Building Release configuration for TestFlight with App Store provisioning profile"
          
          # Build and archive the app with explicit code signing parameters
          xcodebuild -workspace $WORKSPACE \
            -scheme $SCHEME \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
            -allowProvisioningUpdates \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            DEVELOPMENT_TEAM="KLZJM4HJLT" \
            PROVISIONING_PROFILE_SPECIFIER="$PP_NAME" \
            archive
          
          # Export the archive for App Store distribution
          # This creates an IPA that's properly signed for TestFlight/App Store
          EXPORT_PLIST="$RUNNER_TEMP/ExportOptions.plist"

          cat > "$EXPORT_PLIST" <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>app-store</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>teamID</key>
            <string>KLZJM4HJLT</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>com.aatozinnovations.myledguitar</key>
              <string>$PP_NAME</string>
            </dict>
            <key>compileBitcode</key>
            <false/>
            <key>uploadBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
          </dict>
          </plist>
          EOF

          xcodebuild -exportArchive \
            -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
            -exportOptionsPlist "$EXPORT_PLIST" \
            -exportPath $RUNNER_TEMP/build
          
          echo "Build complete, ready for TestFlight upload"
      
      # Upload the IPA to App Store Connect, which makes it available in TestFlight
      # This uses the App Store Connect API for authentication
      # After upload, the build will be processed by Apple (usually takes 10-30 minutes)
      # Once processing completes, the build becomes available to your TestFlight testers
      - name: Upload to TestFlight
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}
        run: |
          # Validate API credentials
          if [ -z "$APP_STORE_CONNECT_API_KEY_ID" ] || [ -z "$APP_STORE_CONNECT_API_ISSUER_ID" ] || [ -z "$APP_STORE_CONNECT_API_KEY_CONTENT" ]; then
            echo "ERROR: App Store Connect API credentials are not fully configured"
            echo "Please ensure APP_STORE_CONNECT_API_KEY_ID, APP_STORE_CONNECT_API_ISSUER_ID, and APP_STORE_CONNECT_API_KEY_CONTENT are set in GitHub secrets"
            exit 1
          fi
          
          # Save the API key to a temporary file
          # The .p8 file is your private key for authenticating with App Store Connect
          echo "$APP_STORE_CONNECT_API_KEY_CONTENT" > $RUNNER_TEMP/AuthKey.p8
          
          # Find the IPA file that was just built
          IPA_PATH=$(find $RUNNER_TEMP/build -name "*.ipa" | head -n 1)
          
          if [ -z "$IPA_PATH" ]; then
            echo "ERROR: No IPA file found in build directory"
            exit 1
          fi
          
          echo "Uploading IPA to TestFlight: $IPA_PATH"
          echo "Build size: $(du -h "$IPA_PATH" | cut -f1)"
          
          # Upload to App Store Connect using xcrun altool
          # Note: altool is deprecated but still works. Apple recommends using xcrun notarytool
          # or the Transporter app, but altool is simpler for CI/CD pipelines
          xcrun altool --upload-app \
            --type ios \
            --file "$IPA_PATH" \
            --apiKey $APP_STORE_CONNECT_API_KEY_ID \
            --apiIssuer $APP_STORE_CONNECT_API_ISSUER_ID
          
          if [ $? -eq 0 ]; then
            echo "âœ“ Successfully uploaded to TestFlight!"
            echo ""
            echo "Next steps:"
            echo "1. Wait for Apple to process the build (usually 10-30 minutes)"
            echo "2. Check App Store Connect to see when processing completes"
            echo "3. Add compliance information if required"
            echo "4. Enable the build for your test groups"
            echo "5. Your testers will receive a notification when the build is ready"
          else
            echo "ERROR: Upload to TestFlight failed"
            echo "Check the error message above for details"
            exit 1
          fi
      
      # Save the IPA as an artifact for backup/manual distribution
      # This is useful if you need to download the exact build that was uploaded to TestFlight
      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-testflight-release-$(date +%Y%m%d-%H%M%S)
          path: ${{ runner.temp }}/build/*.ipa
          retention-days: 90
      
      # Clean up sensitive files
      # Always runs even if previous steps failed to ensure secrets don't persist
      - name: Clean up keychain and API key
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
          rm -f $RUNNER_TEMP/AuthKey.p8