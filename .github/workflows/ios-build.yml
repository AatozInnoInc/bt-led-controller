name: iOS Build

on:
  # Trigger on pushes to main (production) or develop (development)
  push:
    branches:
      - main
      - develop
  # Allow manual triggers with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Build environment'
        required: true
        type: choice
        options:
          - development
          - production

jobs:
  build-ios:
    runs-on: macos-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Determine which environment to build based on trigger type and branch
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
          fi
          
          # Log which environment we're building for visibility
          echo "Building for environment: $(cat $GITHUB_OUTPUT | grep environment | cut -d'=' -f2)"
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
      
      - name: Install Pods
        working-directory: ios
        run: pod install
      
      # This step now handles both provisioning profiles intelligently
      # It will install the Ad Hoc profile for development builds
      # and the App Store profile for production builds
      - name: Setup code signing
        env:
          # Certificate (same for both environments)
          CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          # Provisioning profiles (different for each environment)
          PROVISIONING_PROFILE_ADHOC_BASE64: ${{ secrets.PROVISIONING_PROFILE_ADHOC_BASE64 }}
          PROVISIONING_PROFILE_APPSTORE_BASE64: ${{ secrets.PROVISIONING_PROFILE_APPSTORE_BASE64 }}
          BUILD_ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
        run: |
          # Create file path variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERT_BASE64_FILE=$RUNNER_TEMP/cert.b64
          PP_BASE64_FILE=$RUNNER_TEMP/pp.b64

          # Validate that certificate secret exists
          if [ -z "$CERTIFICATE_BASE64" ]; then
            echo "ERROR: BUILD_CERTIFICATE_BASE64 secret is not set"
            exit 1
          fi

          # Select the correct provisioning profile based on build environment
          if [ "$BUILD_ENVIRONMENT" == "production" ]; then
            echo "Using App Store provisioning profile for production build"
            if [ -z "$PROVISIONING_PROFILE_APPSTORE_BASE64" ]; then
              echo "ERROR: PROVISIONING_PROFILE_APPSTORE_BASE64 secret is not set"
              exit 1
            fi
            PROVISIONING_PROFILE_BASE64="$PROVISIONING_PROFILE_APPSTORE_BASE64"
          else
            echo "Using Ad Hoc provisioning profile for development build"
            if [ -z "$PROVISIONING_PROFILE_ADHOC_BASE64" ]; then
              echo "ERROR: PROVISIONING_PROFILE_ADHOC_BASE64 secret is not set"
              exit 1
            fi
            PROVISIONING_PROFILE_BASE64="$PROVISIONING_PROFILE_ADHOC_BASE64"
          fi

          # Show lengths for debugging (doesn't expose actual secrets)
          echo "Certificate base64 length: ${#CERTIFICATE_BASE64}"
          echo "Provisioning profile base64 length: ${#PROVISIONING_PROFILE_BASE64}"

          # Write base64 data to temporary files
          echo "$CERTIFICATE_BASE64" > $CERT_BASE64_FILE
          echo "$PROVISIONING_PROFILE_BASE64" > $PP_BASE64_FILE

          # Decode certificate from base64
          base64 --decode -i $CERT_BASE64_FILE -o $CERTIFICATE_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode certificate"
            exit 1
          fi
          
          # Decode provisioning profile from base64
          base64 --decode -i $PP_BASE64_FILE -o $PP_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode provisioning profile"
            exit 1
          fi

          # Verify the decoded files have content
          if [ ! -s "$CERTIFICATE_PATH" ]; then
            echo "ERROR: Certificate file is empty"
            exit 1
          fi
          
          if [ ! -s "$PP_PATH" ]; then
            echo "ERROR: Provisioning profile file is empty"
            exit 1
          fi

          echo "Successfully decoded certificate ($(wc -c < $CERTIFICATE_PATH) bytes)"
          echo "Successfully decoded provisioning profile ($(wc -c < $PP_PATH) bytes)"
          
          # Create a temporary keychain for code signing
          # This keychain is isolated from the system keychain and will be deleted after the build
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import the certificate into the temporary keychain
          # The -A flag allows all apps to access this certificate without prompting
          security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Install the provisioning profile in the standard location where Xcode looks for it
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles
          
          # Get the UUID of the provisioning profile so we can reference it explicitly in the build
          # Provisioning profiles are XML plists, and the UUID is stored in the file
          PP_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(security cms -D -i $PP_PATH))
          echo "Provisioning profile UUID: $PP_UUID"
          
          # Rename the profile to use its UUID as the filename
          # This is the naming convention Xcode expects in the Provisioning Profiles directory
          mv ~/Library/MobileDevice/Provisioning\ Profiles/build_pp.mobileprovision \
             ~/Library/MobileDevice/Provisioning\ Profiles/$PP_UUID.mobileprovision
          
          # Clean up temporary base64 files (but keep the decoded files for the build step)
          rm -f $CERT_BASE64_FILE $PP_BASE64_FILE
          
          echo "Code signing setup complete"
      
      # Build the app using xcodebuild
      # The process differs between development and production builds
      - name: Build iOS app
        env:
          BUILD_ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
        working-directory: ios
        run: |
          # The workspace name should match your actual .xcworkspace file
          WORKSPACE="MyLedGuitarApp.xcworkspace"
          # The scheme name should match your Xcode scheme
          SCHEME="MyLedGuitarApp"
          
          if [ "$BUILD_ENVIRONMENT" == "production" ]; then
            echo "Building production release for App Store distribution"
            
            # For production, we build in Release configuration
            # This enables optimizations and strips debug symbols
            xcodebuild -workspace $WORKSPACE \
              -scheme $SCHEME \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              archive
            
            # Export the archive as an IPA suitable for App Store submission
            # The ExportOptions.plist tells Xcode how to package the IPA
            xcodebuild -exportArchive \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -exportOptionsPlist ExportOptions.plist \
              -exportPath $RUNNER_TEMP/build
          else
            echo "Building development build for Ad Hoc distribution"
            
            # For development, we can use Debug or Release configuration
            # Debug includes more debugging information but is larger
            # Using Release here to keep file sizes down and match production behavior
            xcodebuild -workspace $WORKSPACE \
              -scheme $SCHEME \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              archive
            
            # Export as an Ad Hoc IPA that can be installed on registered devices
            xcodebuild -exportArchive \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -exportOptionsPlist ExportOptions-Dev.plist \
              -exportPath $RUNNER_TEMP/build
          fi
          
          echo "Build completed successfully"
      
      # Upload the IPA as a GitHub Actions artifact
      # This makes the file downloadable from the Actions run page
      - name: Upload IPA
        uses: actions/upload-artifact@v4
        with:
          name: ios-${{ steps.set-env.outputs.environment }}-build
          path: ${{ runner.temp }}/build/*.ipa
          retention-days: 30
      
      # Always clean up the keychain, even if previous steps failed
      # This prevents secrets from persisting on the runner
      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true