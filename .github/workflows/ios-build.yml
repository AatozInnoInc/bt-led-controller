name: iOS Build

on:
  # Trigger on pushes to main (production) or develop (development)
  push:
    branches:
      - main
      - develop
  # Allow manual triggers with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Build environment'
        required: true
        type: choice
        options:
          - development
          - production

jobs:
  build-ios:
    runs-on: macos-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Determine which environment to build based on trigger type and branch
      # Development builds use Ad Hoc profiles for direct device installation
      # Production builds use App Store profiles for TestFlight/App Store distribution
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
          fi
          
          # Log which environment we're building for visibility
          ENVIRONMENT=$(cat $GITHUB_OUTPUT | grep environment | cut -d'=' -f2)
          echo "Building for environment: $ENVIRONMENT"
          
          if [ "$ENVIRONMENT" == "production" ]; then
            echo "This build will use the App Store provisioning profile and can be uploaded to TestFlight"
          else
            echo "This build will use the Ad Hoc provisioning profile and can be installed on registered devices"
          fi
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
      
      - name: Install Pods
        working-directory: ios
        run: pod install
      
      # This step sets up code signing by installing the appropriate provisioning profile
      # For development builds, we use the Ad Hoc profile which allows installation on registered devices
      # For production builds, we use the App Store profile which is required for TestFlight and App Store
      - name: Setup code signing
        id: setup-code-signing
        env:
          CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          PROVISIONING_PROFILE_ADHOC_BASE64: ${{ secrets.PROVISIONING_PROFILE_ADHOC_BASE64 }}
          PROVISIONING_PROFILE_APPSTORE_BASE64: ${{ secrets.PROVISIONING_PROFILE_APPSTORE_BASE64 }}
          BUILD_ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
        run: |
          # Create file path variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERT_BASE64_FILE=$RUNNER_TEMP/cert.b64
          PP_BASE64_FILE=$RUNNER_TEMP/pp.b64

          # Validate that certificate secret exists
          if [ -z "$CERTIFICATE_BASE64" ]; then
            echo "ERROR: BUILD_CERTIFICATE_BASE64 secret is not set"
            exit 1
          fi

          # Select the correct provisioning profile based on build environment
          # Ad Hoc profiles are for direct device installation
          # App Store profiles are required for TestFlight and App Store submission
          if [ "$BUILD_ENVIRONMENT" == "production" ]; then
            echo "Using App Store provisioning profile for production build"
            if [ -z "$PROVISIONING_PROFILE_APPSTORE_BASE64" ]; then
              echo "ERROR: PROVISIONING_PROFILE_APPSTORE_BASE64 secret is not set"
              exit 1
            fi
            PROVISIONING_PROFILE_BASE64="$PROVISIONING_PROFILE_APPSTORE_BASE64"
          else
            echo "Using Ad Hoc provisioning profile for development build"
            if [ -z "$PROVISIONING_PROFILE_ADHOC_BASE64" ]; then
              echo "ERROR: PROVISIONING_PROFILE_ADHOC_BASE64 secret is not set"
              exit 1
            fi
            PROVISIONING_PROFILE_BASE64="$PROVISIONING_PROFILE_ADHOC_BASE64"
          fi

          echo "Certificate base64 length: ${#CERTIFICATE_BASE64}"
          echo "Provisioning profile base64 length: ${#PROVISIONING_PROFILE_BASE64}"

          # Write base64 data to temporary files
          echo "$CERTIFICATE_BASE64" > $CERT_BASE64_FILE
          echo "$PROVISIONING_PROFILE_BASE64" > $PP_BASE64_FILE

          # Decode certificate from base64
          base64 --decode -i $CERT_BASE64_FILE -o $CERTIFICATE_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode certificate"
            exit 1
          fi
          
          # Decode provisioning profile from base64
          base64 --decode -i $PP_BASE64_FILE -o $PP_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode provisioning profile"
            exit 1
          fi

          # Verify the decoded files have content
          if [ ! -s "$CERTIFICATE_PATH" ]; then
            echo "ERROR: Certificate file is empty"
            exit 1
          fi
          
          if [ ! -s "$PP_PATH" ]; then
            echo "ERROR: Provisioning profile file is empty"
            exit 1
          fi

          echo "Successfully decoded certificate ($(wc -c < $CERTIFICATE_PATH) bytes)"
          echo "Successfully decoded provisioning profile ($(wc -c < $PP_PATH) bytes)"
          
          # Create a temporary keychain for code signing
          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Configure the keychain settings
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          
          # Unlock the keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Set this keychain as the default
          echo "Setting keychain as default..."
          security list-keychain -d user -s $KEYCHAIN_PATH
          security default-keychain -s $KEYCHAIN_PATH

          # Before importing, let's examine the p12 file to see what's inside it
          echo "Examining certificate file..."
          echo "Certificate file size: $(wc -c < $CERTIFICATE_PATH) bytes"
          
          # Try to get information about the p12 file structure
          # This will help us understand what's inside without importing it
          echo "Certificate file contents:"
          openssl pkcs12 -in $CERTIFICATE_PATH -passin pass:"$CERTIFICATE_PASSWORD" -info -noout -legacy 2>&1 || echo "Could not read with legacy flag, trying without..."
          openssl pkcs12 -in $CERTIFICATE_PATH -passin pass:"$CERTIFICATE_PASSWORD" -info -noout 2>&1 || echo "OpenSSL could not parse the p12 file"
          
          # Import the certificate with verbose error checking
          echo "Importing certificate..."
          security import $CERTIFICATE_PATH \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k $KEYCHAIN_PATH \
            -T /usr/bin/codesign \
            -T /usr/bin/security
          
          IMPORT_RESULT=$?
          echo "Import command exit code: $IMPORT_RESULT"
          
          # Check what actually got imported
          echo "Checking keychain contents after import..."
          security dump-keychain $KEYCHAIN_PATH || echo "Could not dump keychain"
          
          # Look for any certificates
          echo "Searching for certificates in keychain..."
          security find-certificate -a -p $KEYCHAIN_PATH | openssl x509 -noout -subject -dates 2>/dev/null || echo "No certificates found"
          
          # Look specifically for code signing identities
          echo "Searching for code signing identities..."
          security find-identity -v -p codesigning $KEYCHAIN_PATH
          
          # Count how many valid identities we have
          IDENTITY_COUNT=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep -c "valid identities found")
          echo "Found identities: $IDENTITY_COUNT"
          
          # If no identities found, try alternative import method
          if security find-identity -v -p codesigning $KEYCHAIN_PATH | grep -q "0 valid identities found"; then
            echo "ERROR: No valid code signing identities found after import"
            echo "Attempting alternative import method..."
            
            # Try extracting and importing certificate and key separately
            echo "Extracting certificate from p12..."
            openssl pkcs12 -in $CERTIFICATE_PATH -passin pass:"$CERTIFICATE_PASSWORD" -clcerts -nokeys -out $RUNNER_TEMP/cert.pem -legacy 2>&1
            
            echo "Extracting private key from p12..."
            openssl pkcs12 -in $CERTIFICATE_PATH -passin pass:"$CERTIFICATE_PASSWORD" -nocerts -nodes -out $RUNNER_TEMP/key.pem -legacy 2>&1
            
            # Check if extraction succeeded
            if [ -s "$RUNNER_TEMP/cert.pem" ] && [ -s "$RUNNER_TEMP/key.pem" ]; then
              echo "Successfully extracted certificate and key, importing separately..."
              
              # Import certificate
              security import $RUNNER_TEMP/cert.pem -k $KEYCHAIN_PATH -T /usr/bin/codesign -T /usr/bin/security
              
              # Import key
              security import $RUNNER_TEMP/key.pem -k $KEYCHAIN_PATH -T /usr/bin/codesign -T /usr/bin/security
              
              # Check again for identities
              echo "Checking for identities after separate import..."
              security find-identity -v -p codesigning $KEYCHAIN_PATH
              
              # Clean up PEM files
              rm -f $RUNNER_TEMP/cert.pem $RUNNER_TEMP/key.pem
            else
              echo "ERROR: Could not extract certificate or key from p12 file"
              echo "The p12 file may be corrupted or in an unsupported format"
              exit 1
            fi
          fi
          
          # Final verification that we have a valid identity
          if security find-identity -v -p codesigning $KEYCHAIN_PATH | grep -q "0 valid identities found"; then
            echo "ERROR: Still no valid code signing identities found"
            echo "Please verify:"
            echo "1. The certificate has not expired"
            echo "2. The p12 file was exported correctly from Keychain Access"
            echo "3. The certificate password is correct"
            echo "4. The certificate is an iOS Distribution certificate"
            exit 1
          fi
          
          echo "Successfully imported code signing identity"
          
          # Set the keychain partition list to allow codesign to access the private key
          echo "Configuring keychain access permissions..."
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            $KEYCHAIN_PATH
          
          echo "Code signing identity setup complete"

          # Install the provisioning profile in the standard location where Xcode looks for it
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles
          
          # Get the UUID of the provisioning profile so we can reference it explicitly in the build
          # Provisioning profiles are XML plists, and the UUID is stored in the file
          PP_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(security cms -D -i $PP_PATH))
          echo "Provisioning profile UUID: $PP_UUID"
          
          # Save the UUID as a step output so it can be used in the build step
          echo "PP_UUID=$PP_UUID" >> $GITHUB_OUTPUT
          
          # Rename the profile to use its UUID as the filename
          # This is the naming convention Xcode expects in the Provisioning Profiles directory
          mv ~/Library/MobileDevice/Provisioning\ Profiles/build_pp.mobileprovision \
             ~/Library/MobileDevice/Provisioning\ Profiles/$PP_UUID.mobileprovision
          
          # Clean up temporary base64 files (but keep the decoded files for the build step)
          rm -f $CERT_BASE64_FILE $PP_BASE64_FILE
          
          echo "Code signing setup complete"
      
      # Build the app using xcodebuild
      # Development builds create Ad Hoc IPAs for direct device installation
      # Production builds create App Store IPAs suitable for TestFlight or App Store submission
      - name: Build iOS app
        env:
          BUILD_ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
          PP_UUID: ${{ steps.setup-code-signing.outputs.PP_UUID }}
        working-directory: ios
        run: |
          # The workspace name should match your actual .xcworkspace file
          WORKSPACE="MyLedGuitarApp.xcworkspace"
          # The scheme name should match your Xcode scheme
          SCHEME="MyLedGuitarApp"
          
          # Both development and production builds use Release configuration
          # Release configuration enables optimizations and is suitable for distribution
          # The key difference is which provisioning profile type we use
          
          if [ "$BUILD_ENVIRONMENT" == "production" ]; then
            echo "Building production release with App Store provisioning profile"
            echo "This build can be uploaded to TestFlight or submitted to the App Store"
            
            # Build and archive the app
            # We explicitly override all code signing settings to use our Distribution certificate and App Store profile
            # The -allowProvisioningUpdates flag lets xcodebuild accept Distribution profiles
            xcodebuild -workspace $WORKSPACE \
              -scheme $SCHEME \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -allowProvisioningUpdates \
              CODE_SIGN_STYLE=Manual \
              CODE_SIGN_IDENTITY="iOS Distribution" \
              DEVELOPMENT_TEAM="KLZJM4HJLT" \
              PROVISIONING_PROFILE="$PP_UUID" \
              PROVISIONING_PROFILE_SPECIFIER="$PP_UUID" \
              archive
            
            # Export the archive as an IPA suitable for App Store submission
            # The ExportOptions.plist tells Xcode how to package the IPA
            xcodebuild -exportArchive \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -exportOptionsPlist ExportOptions.plist \
              -exportPath $RUNNER_TEMP/build
          else
            echo "Building development build with Ad Hoc provisioning profile"
            echo "This build can be installed on registered devices but cannot be uploaded to TestFlight"
            
            # Build and archive the app
            # Same parameters as production but using the Ad Hoc profile
            xcodebuild -workspace $WORKSPACE \
              -scheme $SCHEME \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -allowProvisioningUpdates \
              CODE_SIGN_STYLE=Manual \
              CODE_SIGN_IDENTITY="iOS Distribution" \
              DEVELOPMENT_TEAM="KLZJM4HJLT" \
              PROVISIONING_PROFILE="$PP_UUID" \
              PROVISIONING_PROFILE_SPECIFIER="$PP_UUID" \
              archive
            
            # Export as an Ad Hoc IPA that can be installed on registered devices
            xcodebuild -exportArchive \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -exportOptionsPlist ExportOptions-Dev.plist \
              -exportPath $RUNNER_TEMP/build
          fi
          
          echo "Build completed successfully"
      
      # Upload the IPA as a GitHub Actions artifact
      # This makes the file downloadable from the Actions run page
      # Development builds can be installed directly on registered devices
      # Production builds can be manually uploaded to TestFlight or downloaded for inspection
      - name: Upload IPA
        uses: actions/upload-artifact@v4
        with:
          name: ios-${{ steps.set-env.outputs.environment }}-build
          path: ${{ runner.temp }}/build/*.ipa
          retention-days: 30
      
      # Always clean up the keychain, even if previous steps failed
      # This prevents secrets from persisting on the runner
      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true