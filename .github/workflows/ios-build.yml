name: iOS Build

on:
  # Trigger on pushes to main (production) or develop (development)
  push:
    branches:
      - main
      - develop
  # Allow manual triggers with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Build environment'
        required: true
        type: choice
        options:
          - development
          - production

jobs:
  build-ios:
    runs-on: macos-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Determine which environment to build based on trigger type and branch
      # Development builds use Ad Hoc profiles for direct device installation
      # Production builds use App Store profiles for TestFlight/App Store distribution
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
          fi
          
          # Log which environment we're building for visibility
          ENVIRONMENT=$(cat $GITHUB_OUTPUT | grep environment | cut -d'=' -f2)
          echo "Building for environment: $ENVIRONMENT"
          
          if [ "$ENVIRONMENT" == "production" ]; then
            echo "This build will use the App Store provisioning profile and can be uploaded to TestFlight"
          else
            echo "This build will use the Ad Hoc provisioning profile and can be installed on registered devices"
          fi
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
      
      - name: Install Pods
        working-directory: ios
        run: pod install
      
      # This step sets up code signing by installing the appropriate provisioning profile
      # For development builds, we use the Ad Hoc profile which allows installation on registered devices
      # For production builds, we use the App Store profile which is required for TestFlight and App Store
      - name: Setup code signing
        id: setup-code-signing
        env:
          CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          PROVISIONING_PROFILE_ADHOC_BASE64: ${{ secrets.PROVISIONING_PROFILE_ADHOC_BASE64 }}
          PROVISIONING_PROFILE_APPSTORE_BASE64: ${{ secrets.PROVISIONING_PROFILE_APPSTORE_BASE64 }}
          BUILD_ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
        run: |
          # Create file path variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERT_BASE64_FILE=$RUNNER_TEMP/cert.b64
          PP_BASE64_FILE=$RUNNER_TEMP/pp.b64

          # Validate that certificate secret exists
          if [ -z "$CERTIFICATE_BASE64" ]; then
            echo "ERROR: BUILD_CERTIFICATE_BASE64 secret is not set"
            exit 1
          fi

          # Select the correct provisioning profile based on build environment
          # Ad Hoc profiles are for direct device installation
          # App Store profiles are required for TestFlight and App Store submission
          if [ "$BUILD_ENVIRONMENT" == "production" ]; then
            echo "Using App Store provisioning profile for production build"
            if [ -z "$PROVISIONING_PROFILE_APPSTORE_BASE64" ]; then
              echo "ERROR: PROVISIONING_PROFILE_APPSTORE_BASE64 secret is not set"
              exit 1
            fi
            PROVISIONING_PROFILE_BASE64="$PROVISIONING_PROFILE_APPSTORE_BASE64"
          else
            echo "Using Ad Hoc provisioning profile for development build"
            if [ -z "$PROVISIONING_PROFILE_ADHOC_BASE64" ]; then
              echo "ERROR: PROVISIONING_PROFILE_ADHOC_BASE64 secret is not set"
              exit 1
            fi
            PROVISIONING_PROFILE_BASE64="$PROVISIONING_PROFILE_ADHOC_BASE64"
          fi

          echo "Certificate base64 length: ${#CERTIFICATE_BASE64}"
          echo "Provisioning profile base64 length: ${#PROVISIONING_PROFILE_BASE64}"

          # Write base64 data to temporary files
          echo "$CERTIFICATE_BASE64" > $CERT_BASE64_FILE
          echo "$PROVISIONING_PROFILE_BASE64" > $PP_BASE64_FILE

          # Decode certificate from base64
          base64 --decode -i $CERT_BASE64_FILE -o $CERTIFICATE_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode certificate"
            exit 1
          fi
          
          # Decode provisioning profile from base64
          base64 --decode -i $PP_BASE64_FILE -o $PP_PATH
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to decode provisioning profile"
            exit 1
          fi

          # Verify the decoded files have content
          if [ ! -s "$CERTIFICATE_PATH" ]; then
            echo "ERROR: Certificate file is empty"
            exit 1
          fi
          
          if [ ! -s "$PP_PATH" ]; then
            echo "ERROR: Provisioning profile file is empty"
            exit 1
          fi

          echo "Successfully decoded certificate ($(wc -c < $CERTIFICATE_PATH) bytes)"
          echo "Successfully decoded provisioning profile ($(wc -c < $PP_PATH) bytes)"
          
          # Create a temporary keychain for code signing
          # This keychain is isolated from the system keychain and will be deleted after the build
          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Configure the keychain settings before we start using it
          # The -lut flag sets the timeout to 6 hours (21600 seconds) so it won't lock during the build
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          
          # Unlock the keychain so we can import items into it
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # CRITICAL: Set this keychain as the default search keychain BEFORE importing
          # This ensures all subsequent security commands know where to look
          echo "Setting keychain as default..."
          security list-keychain -d user -s $KEYCHAIN_PATH
          security default-keychain -s $KEYCHAIN_PATH

          # Import the certificate into the temporary keychain
          # The -A flag allows all apps to access this certificate without prompting
          # The -T flag explicitly grants access to codesign and security tools
          echo "Importing certificate..."
          security import $CERTIFICATE_PATH \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k $KEYCHAIN_PATH \
            -T /usr/bin/codesign \
            -T /usr/bin/security
          
          # Verify the certificate was imported by listing identities
          echo "Verifying certificate import..."
          security find-identity -v -p codesigning $KEYCHAIN_PATH
          
          # Set the keychain partition list to allow codesign to access the private key
          # This must happen AFTER the certificate is imported and the keychain is set as default
          # The -k flag provides the password, -S specifies which tools can access it
          echo "Configuring keychain access permissions..."
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            $KEYCHAIN_PATH
          
          echo "Code signing identity setup complete"

          # Install the provisioning profile in the standard location where Xcode looks for it
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles
          
          # Get the UUID of the provisioning profile so we can reference it explicitly in the build
          # Provisioning profiles are XML plists, and the UUID is stored in the file
          PP_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin <<< $(security cms -D -i $PP_PATH))
          echo "Provisioning profile UUID: $PP_UUID"
          
          # Save the UUID as a step output so it can be used in the build step
          echo "PP_UUID=$PP_UUID" >> $GITHUB_OUTPUT
          
          # Rename the profile to use its UUID as the filename
          # This is the naming convention Xcode expects in the Provisioning Profiles directory
          mv ~/Library/MobileDevice/Provisioning\ Profiles/build_pp.mobileprovision \
             ~/Library/MobileDevice/Provisioning\ Profiles/$PP_UUID.mobileprovision
          
          # Clean up temporary base64 files (but keep the decoded files for the build step)
          rm -f $CERT_BASE64_FILE $PP_BASE64_FILE
          
          echo "Code signing setup complete"
      
      # Build the app using xcodebuild
      # Development builds create Ad Hoc IPAs for direct device installation
      # Production builds create App Store IPAs suitable for TestFlight or App Store submission
      - name: Build iOS app
        env:
          BUILD_ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
          PP_UUID: ${{ steps.setup-code-signing.outputs.PP_UUID }}
        working-directory: ios
        run: |
          # The workspace name should match your actual .xcworkspace file
          WORKSPACE="MyLedGuitarApp.xcworkspace"
          # The scheme name should match your Xcode scheme
          SCHEME="MyLedGuitarApp"
          
          # Both development and production builds use Release configuration
          # Release configuration enables optimizations and is suitable for distribution
          # The key difference is which provisioning profile type we use
          
          if [ "$BUILD_ENVIRONMENT" == "production" ]; then
            echo "Building production release with App Store provisioning profile"
            echo "This build can be uploaded to TestFlight or submitted to the App Store"
            
            # Build and archive the app
            # We explicitly override all code signing settings to use our Distribution certificate and App Store profile
            # The -allowProvisioningUpdates flag lets xcodebuild accept Distribution profiles
            xcodebuild -workspace $WORKSPACE \
              -scheme $SCHEME \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -allowProvisioningUpdates \
              CODE_SIGN_STYLE=Manual \
              CODE_SIGN_IDENTITY="iOS Distribution" \
              DEVELOPMENT_TEAM="KLZJM4HJLT" \
              PROVISIONING_PROFILE="$PP_UUID" \
              PROVISIONING_PROFILE_SPECIFIER="$PP_UUID" \
              archive
            
            # Export the archive as an IPA suitable for App Store submission
            # The ExportOptions.plist tells Xcode how to package the IPA
            xcodebuild -exportArchive \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -exportOptionsPlist ExportOptions.plist \
              -exportPath $RUNNER_TEMP/build
          else
            echo "Building development build with Ad Hoc provisioning profile"
            echo "This build can be installed on registered devices but cannot be uploaded to TestFlight"
            
            # Build and archive the app
            # Same parameters as production but using the Ad Hoc profile
            xcodebuild -workspace $WORKSPACE \
              -scheme $SCHEME \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -allowProvisioningUpdates \
              CODE_SIGN_STYLE=Manual \
              CODE_SIGN_IDENTITY="iOS Distribution" \
              DEVELOPMENT_TEAM="KLZJM4HJLT" \
              PROVISIONING_PROFILE="$PP_UUID" \
              PROVISIONING_PROFILE_SPECIFIER="$PP_UUID" \
              archive
            
            # Export as an Ad Hoc IPA that can be installed on registered devices
            xcodebuild -exportArchive \
              -archivePath $RUNNER_TEMP/MyLedGuitarApp.xcarchive \
              -exportOptionsPlist ExportOptions-Dev.plist \
              -exportPath $RUNNER_TEMP/build
          fi
          
          echo "Build completed successfully"
      
      # Upload the IPA as a GitHub Actions artifact
      # This makes the file downloadable from the Actions run page
      # Development builds can be installed directly on registered devices
      # Production builds can be manually uploaded to TestFlight or downloaded for inspection
      - name: Upload IPA
        uses: actions/upload-artifact@v4
        with:
          name: ios-${{ steps.set-env.outputs.environment }}-build
          path: ${{ runner.temp }}/build/*.ipa
          retention-days: 30
      
      # Always clean up the keychain, even if previous steps failed
      # This prevents secrets from persisting on the runner
      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true